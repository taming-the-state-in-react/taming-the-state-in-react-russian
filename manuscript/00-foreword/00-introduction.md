# Введение

Управление состоянием в веб-приложениях стало популярной темой в последние годы. [Одностраничные приложения (SPA)](https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5) — которые загружаются только один раз с веб-сервера, но остаются интерактивными на клиенте — должны установить управление состоянием на клиенте. Они должны поддерживать согласованность состояния в фронтенд-приложении без каких-либо дополнительных запросов к бекенд-приложению. Они должны дать пользователю легкий и приятный опыт при использовании приложения. Он уже выполняются при открытии всплывающего окна в вашем приложении. Должно быть возможно открыть и закрыть его. Поэтому кто-то должен знать об этом состоянии. Но кто управляет этим состоянием, если это не бекэнд-приложение?

[jQuery](https://ru.wikipedia.org/wiki/JQuery) была популярной библиотекой до появления первых SPA-решений, таких как Angular, Ember и Backbone. Само управление состоянием не было большой проблемой в jQuery в самом начале, потому что эта библиотека чаще всего использовалась только для выборочных манипуляций с DOM. Вы можете добавить анимацию в свой HTML, добавить или удалить DOM-узлы или программно изменить стиль своего HTML. Это сделало веб-приложение более приятным, сделав их интерактивными.

В конце концов, код jQuery и, в общем, часть кода JavaScript в отличие от HTML и CSS росли, и люди писали более сложные интерфейсные приложения. Большую часть времени он оказался в беспорядке кода jQuery, где проблема не только в управлении состоянием, но и в таких распространённых передовых практиках, таких как чистый код, отсутствовали. Не было решения общей архитектуры для подобных приложений, и люди изо всех сил старались поддерживать его в больших приложениях.

Через некоторое время появились решения для одностраничного приложения (SPA), такие как Angular, Ember и Backbone, чтобы обеспечить эти неструктурированные интерфейсные приложения надлежащей архитектурой. Большая часть SPA формируется на паттерне [model-view-controller (MVC)](https://ru.wikipedia.org/wiki/Model-view-controller) для разработки архитектуры приложения. Указанные фреймворки содержат все, что вам нужно, от уровня представления для отображения HTML в браузере до уровня модели для взаимодействия с вашим бекэндом для создания сложного приложения. Термин SPA был придуман, поскольку эти приложения обслуживаются только один раз с веб-сервера, как одна страница, но затем работают только на стороне клиента. Это капли HTML, связанные с JavaScript, которые содержат все приложения, которые должны работать на стороне клиента. При переходе на другую страницу под другим URL-адресом для получения HTML-кода с использованием JavaScript не требуется дополнительного запроса сервера. SPA взаимодействуют только с бекэндом, чтобы получать или отправлять новые данные из или в него. Таким образом, единственное, что меняется, — это состояние внутри клиентского приложения, поскольку данные считываются и записываются на бекэнд и из него, а взаимодействия, такие как всплывающие окна, фильтры и модальные окна, должно работать. Но кто управляет этим состоянием, чтобы поддерживать целостность на клиентской стороны?

Несмотря на то, что эти фреймворки для SPA установили передовые практики, паттерны и архитектуры для первого поколения SPA, управление состоянием стало для них повторяющейся проблемой. При взаимодействии с бекэндом для получения новых данных было непонятно, как управлять данными предсказуемым образом. При запуске представления связанных элементов, таких как модальные окна или всплывающие окна, на фронтенде часто не принято переводой практики для управления этими состояниями. Каждый фреймворк пытается применить к ней собственное решение. В конце концов, люди придумали свои передовые практики и библиотеки, но никогда не стали предсказуемым и последовательным опытом управления состоянием с явными ограничениями.

Был один главный недостаток этих SPA-решений, которые привели к этой проблеме в первую очередь: в качестве фреймворков они пытались решить слишком много проблем одновременно. Поскольку они были первыми из их видов, у них не было возможности решить все проблемы в мире SPA. В конце концов, они решили эти проблемы на другой итерации, когда на сцене появились другие SPA-решения.

Второе поколение SPA-решений, среди которых такие библиотеки, как React и Vue, сосредоточено только на небольших частях приложения. Они сосредоточились на уровне представления. Теперь инженерам предстояло выбирать дополнительные библиотеки как решения конкретных проблем. [Это то, что сделало React такой мощной библиотекой в первую очередь](https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/), потому что каждый мог расширить своё приложение с помощью библиотека, которые решают конкретные, но небольшие проблемы.

В настоящее время куча статей и библиотек пытается решить проблему управления состоянием. Трудно найти последовательный источник правды для изучения управления состоянием в современных приложениях. Несмотря на то, что такие решения, как React, имеют собственную реализацию управления состоянием для локального состояния в компонентах, для таких библиотек, как Redux и MobX, существуют множество внешних решений, которые создают сложное управление состоянием.

Тем не менее, ему не хватает одного руководства для навигации по всем этим различным решениям, чтобы выявить различия и преимущества управления состоянием ясными. Довольно часто руководства упускают из виду проблему сути обучения в первую очередь. Кроме того, вместо того, чтобы показывать минимальный подход, они пытаются решить проблему управления состоянием, используя чрезмерно переусложненные подходы. Но это может быть намного проще. Нужен только один ресурс, который будет указывать путь к последовательному и конструктивному управлению состоянием в современных приложениях. И это миссия этой книги.

Если вы хотите чему-то научиться, вам нужно делать это шаг за шагом. Пытаться решить любую элементарную проблему перед следующей. Не применяйте все сразу. Поймите проблему и решите ее. Это моя попытка с этой книгой: она не только преподает Redux в React, но и управление состоянием в современных приложениях. Она выходит за рамки документации библиотек управления состоянием, но и применяет знания в реальных приложениях в книге.

Книга следует центральной теме управления состоянием в современных приложениях. Она начинается с управления локальным состоянием в библиотеке представления (React), указывает на проблемы её использования в более крупных приложениях и приводит к сложным решениям управления состоянием, таким как Redux и MobX. Пока вы читаете книгу, вы найдете интерактивные площадки для выполнения кода, которые иллюстрируют проблемы и решения. Я рекомендую вам поиграть с этими площадками, чтобы получить практический опыт. Вы даже можете попытаться применить эти фрагменты кода в своем личном редакторе и поиграть с ними. Но не беспокойтесь, если это не сработает в начале. Вы будете руководствоваться мною, чтобы применить свои знания в своем редакторе в разных главах. Однако, не стесняйтесь проверять свои знания как можно раньше.

Это герои книги: локальное состояние (в React), Redux и MobX. Было бы невозможно написать книгу без новаторов, стоящих за этими решениями: [Дэн Абрамов](https://twitter.com/dan_abramov), [Andrew Clark](https://twitter.com/acdlite) и [Michel Weststrate](https://twitter.com/mweststrate). Наверное, я могу поблагодарить их от имени сообщества за их усилия сделать управление состоянием в современных приложениях последовательным и приятным опытом.